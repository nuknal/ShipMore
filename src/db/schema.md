# KnowOneAI 数据库设计文档

## 设计概述

KnowOneAI 应用是一个角色分析和交互平台，允许用户与虚拟角色进行交流并获取分析洞见。本文档详细说明了 PostgreSQL 数据库架构的设计思路和依据。

## 设计原则

在设计数据库架构时，我遵循了以下原则：

1. **范式设计与非范式设计的平衡**：对于核心实体和关系采用关系型设计（第三范式），而对于复杂的嵌套结构和频繁变化的数据使用 JSONB 类型
2. **减少关联查询**：通过合理设计表结构，减少跨表查询的需求，将关联逻辑移至应用层
3. **软删除支持**：所有表都包含 `deleted_at` 字段，支持软删除功能
4. **时间戳追踪**：所有表都包含 `created_at` 和 `updated_at` 字段，便于追踪数据变更
5. **外键约束**：在关键关系上使用外键约束，确保数据完整性

## 表结构设计

### 核心实体表

#### 1. users（用户表）

用户表采用简单的关系型设计，只存储核心信息。用户的认证信息由 Clerk 服务管理，我们只存储必要的关联信息。

#### 2. characters（角色表）

角色表存储角色的基本信息。对于 `relationships` 字段，我们选择使用 JSONB 类型，因为：
- 关系数据结构可能会变化
- 查询时通常一次性获取所有关系数据
- 减少多表关联查询的复杂性

#### 3. messages（消息表）

消息表采用关系型设计，存储用户与角色之间的对话内容。每条消息都关联到特定用户和角色。

### 分析数据表

#### 1. character_analysis（角色分析表）

角色分析表存储对角色的 MBTI、大五人格等分析结果。这些分析数据具有复杂的嵌套结构，且查询时通常整体获取，因此使用 JSONB 类型存储：
- `mbti_analysis`：存储 MBTI 分析结果，包括类型、描述、优势、劣势和认知功能栈
- `big_five_analysis`：存储大五人格分析结果，包括各维度分数和详细解释
- `psychological_traits`：存储心理特质分析结果

#### 2. emotional_analysis（情感分析表）

情感分析表存储角色的情感趋势和情绪调节能力分析。同样使用 JSONB 类型存储复杂结构：
- `emotional_trends`：存储情感趋势数据，包含时间序列的情绪变化
- `emotional_regulation`：存储情绪调节能力评估结果

#### 3. communication_suggestions（交流建议表）

交流建议表存储与角色有效沟通的建议。使用 JSONB 类型存储：
- `communication_preferences`：存储沟通偏好，按类别组织
- `effective_strategies`：存储有效沟通策略

#### 4. analysis_results（分析结果表）

分析结果表存储对用户输入的分析结果。使用 JSONB 类型存储复杂的分析数据：
- `mental`：心理分析结果
- `emotion`：情感分析结果
- `implication`：含义分析结果
- `suggestion`：建议分析结果

### 互动历史表

#### 1. interactions（互动记录表）

互动记录表采用关系型设计，存储用户与角色的互动记录。每条记录都关联到特定用户和角色。

#### 2. significant_events（重要事件表）

重要事件表存储用户与角色之间的重要事件。对于 `tags` 字段，使用 JSONB 类型，因为标签集合可能变化且不需要单独查询。

#### 3. relationship_development（关系发展表）

关系发展表存储用户与角色之间关系的发展状况。采用关系型设计，并与里程碑表建立一对多关系。

#### 4. milestones（里程碑表）

里程碑表存储关系发展过程中的重要里程碑。采用关系型设计，与关系发展表关联。

### 订阅和支付表

#### 1. subscriptions（订阅表）

订阅表存储用户的订阅信息。采用关系型设计，每个用户只有一个活跃订阅。

#### 2. usage_data（使用量表）

使用量表存储用户的功能使用情况。采用关系型设计，每个用户只有一条使用量记录。

#### 3. billing_history（账单历史表）

账单历史表存储用户的支付记录。采用关系型设计，一个用户可以有多条支付记录。

### 辅助表

#### 1. files（文件表）

文件表存储用户上传的文件信息。采用关系型设计，文件的实际内容存储在 Cloudflare R2 中。

#### 2. settings（设置表）

设置表存储用户的应用设置。对于 `preferences` 字段，使用 JSONB 类型，因为用户偏好可能会频繁变化且结构不固定。

## JSONB vs. 关系型设计的选择依据

### 选择 JSONB 的情况

1. **复杂嵌套结构**：当数据具有复杂的嵌套结构，如角色分析结果、情感分析结果等
2. **整体获取**：当数据通常作为整体获取，而不需要单独查询内部字段
3. **结构变化**：当数据结构可能随时间变化，需要灵活性
4. **避免多表关联**：当使用关系型设计会导致过多的表关联，影响性能

### 选择关系型设计的情况

1. **核心实体**：对于应用的核心实体，如用户、角色、消息等
2. **频繁查询和过滤**：当需要频繁基于特定字段进行查询和过滤
3. **数据完整性**：当需要强制保证数据完整性和一致性
4. **固定结构**：当数据结构相对稳定，不太可能变化

## 性能考虑

1. **索引策略**：在频繁查询的字段上创建索引，如 `user_id`、`character_id` 等
2. **JSONB 索引**：对于 JSONB 字段中需要查询的键，可以创建 GIN 索引
3. **分页优化**：对于可能返回大量数据的查询，实现分页机制
4. **软删除**：使用软删除而非物理删除，以便于数据恢复和审计

## 扩展性考虑

1. **版本控制**：数据库设计考虑了未来可能的版本升级
2. **分区表**：对于可能增长较快的表（如消息表、互动记录表），考虑未来实现分区表
3. **水平扩展**：设计允许未来实现读写分离或分片

## 结论

本数据库设计在关系型设计和文档型设计之间取得了平衡，既保证了数据的完整性和一致性，又提供了足够的灵活性和性能。通过将复杂的嵌套结构存储为 JSONB，减少了表的数量和关联查询的复杂性，同时将数据关联逻辑移至应用层，提高了整体性能和可维护性。
